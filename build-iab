#!/usr/bin/env python

import os
from sys import argv

import click
import ipymd
import IPython

def _skipdir(dir):
    return '.ipynb_checkpoints' in dir

_format_ext_map = {'notebook' : 'ipynb'}

_build_map = [('6917e2', '', 'An Introduction to Applied Bioinformatics'),
              ('b4c2f3', '1', 'Getting Started'),
              ('cd74b9', '1/1', 'Installation'),
              ('321abe', '1/2', 'Using IAB'),
              ('d59878', '2', 'Fundamentals'),
              ('e85824', '2/1', 'Pairwise Alignment'),
              ('bc5fe0', '2/2', 'Multiple Sequence Alignment'),
              ('07abc5', '2/2#1', 'Background'),
              ('d4a719', '2/2#2', 'Progressive'),
              ('d9b0ec', '2/2#3', 'Iterative'),
              ('6d2a25', '2/3', 'Phylogenetic Reconstruction'),
              ('cca692', '3', 'Applications'),
              ('30031a', '3/1', 'Studying Biological Diversity'),
              ('6ed3d3', '4', 'Wrapping Up'),
              ('a465da', '4/1', 'Reproducible Bioinformatics')]

toc = """## Table of Contents

%s

"""

def build_link(unit=None, chapter=None, section=None, file_ext=None):
    if unit is None:
        return './'
    elif chapter is None:
        return './%s' % unit
    elif file_ext is None:
        link = './%s/%s' % (unit, chapter)
    else:
        link = './%s/%s%s%s' % (unit, chapter, os.path.extsep, file_ext)

    if section is None:
        return link
    else:
        return '%s#%s' % (link, section)

def link_from_path(path, file_ext):

    if '/' in path:
        unit, chapter_section = path.split('/')
    else:
        return build_link(path, chapter=None, section=None, file_ext=file_ext)

    if '#' in chapter_section:
        chapter, section = chapter_section.split('#')
    else:
        return build_link(unit, chapter=chapter_section, section=None, file_ext=file_ext)

    return build_link(unit, chapter, section, file_ext)

def build_toc_md(root_path=None, file_ext=None):
    """ Build a markdown table of contents of links

        Parameters
        ----------
        root_path : str, None
            The root path to start the table of contents from. If None, start
            at the book's root.
        file_ext : str
            The file extension to append to chapters, if the links that are
            generated need to include a filename extension.

        Returns
        -------
        str
            Markdown text that can be printed as a table of contents.

    """
    lines = []
    if root_path is None:
        search_prefix = ''
    else:
        search_prefix = root_path
    for sha, path, title in _build_map:
        if path.startswith(search_prefix):
            indentation = path.count('/') + path.count('.')
            link = link_from_path(path, file_ext)
            lines.append(' ' * indentation + '* ' + '[%s](%s)' % (title, link))
    return '\n'.join(lines)

def resolve_md_links(md, path, link_ext):
    for sha, path, title in _build_map:
        md.replace('alias://%s' % sha, link_from_path(path, file_ext=link_ext))
    return md

def add_toc_to_md(md, path, link_ext):
    lines = md.split('\n')
    lines = [lines[0]] + [toc % build_toc_md(root_path=path, file_ext=link_ext)] + lines[1:]
    return '\n'.join(lines)

def fp_to_path(fp):
    fields = fp.split(os.path.sep)[1:]
    if fields[-1] == 'index.md':
        fields = fields[:-1]
    else:
        fields[-1] = os.path.splitext(fields[-1])[0]
    return '/'.join(fields)

def get_output_fp(output_root, input_fp, output_ext):
    input_dir, input_fn = os.path.split(input_fp)
    input_basename = os.path.splitext(input_fn)[0]
    input_dirs = input_dir.split(os.path.sep)

    output_fn = os.path.extsep.join([input_basename, output_ext])
    output_dir = os.path.sep.join([output_root] + input_dirs[1:])
    output_fp = os.path.join(output_dir, output_fn)
    return output_dir, output_fp


def convert(input_root, output_root, out_format, dry_run=False,
            format_ext_map=_format_ext_map, include_link_ext=True):
    """ Convert md sources to readable book content, maintaining dir structure.

        A few additional processing steps happen here:
         * Add Table of Contents to the top of each section.
         * Create links from sha1 aliases.

        Parameters
        ----------
        input_root : str
            Root path for the markdown files.
        output_root : str
            Root path for the output files.
        out_format : str
            The ipymd format that output files should be written in (for example,
            ``notebook``).
        dry_run : bool, optional
            If ``True``, don't actually create new directories or write files.
        format_ext_map : dict, optional
            Dict mapping ipymd format to file extension.
        include_link_ext : bool, optional
            If ``True``, when creating links include file extensions.

    """

    # Find the file extension that should be used for this format. If we get
    # a KeyError, this is an unknown output format.
    try:
        output_ext = format_ext_map[out_format]
    except KeyError:
        raise ValueError("Unknown output format: %s. Known formats are: "
                         "%s" % ", ".join(format_ext_map.keys()))
    # If links should include the file extension, define that here. Otherwise,
    # it is set to None, and there will be no extension included in the links.
    if include_link_ext:
        link_ext = output_ext
    else:
        link_ext = None

    # Walk the input root directory. We only care about root and files
    # inside this loop (nothing happens with dirs).
    for root, dirs, files in os.walk(input_root):
        # Determine if current root is one that we want to skip (e.g., a hidden
        # directory). If so, move on...
        if _skipdir(root): continue

        # Iterate over the files in the current root.
        for input_fn in files:
            # Get the full path
            input_fp = os.path.join(root, input_fn)
            # read it into a string
            input_md = open(input_fp).read()
            # get the book path for this file
            path = fp_to_path(input_fp)
            # apply the processing steps
            input_md = resolve_md_links(input_md, path, link_ext)
            input_md = add_toc_to_md(input_md, path, link_ext)
            # Convert it from markdown
            output_s = ipymd.convert(input_md, from_='markdown', to=out_format)
            # define the output filepath
            output_dir, output_fp = get_output_fp(output_root, input_fp, output_ext)

            if dry_run:
                print "Convert %s to %s." % (input_fp, output_fp)
            else:
                try:
                    os.makedirs(output_dir)
                except OSError:
                    pass
                IPython.nbformat.write(output_s, output_fp)

if __name__ == '__main__':
    convert(argv[1], argv[2], argv[3])
    #print build_toc_md('3')
